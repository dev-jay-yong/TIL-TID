# MSA 아키텍처 개념

### MSA(Micro Service Architecture)
> "하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개어 병합과 조합이 가능하도록 만든 아키텍쳐"

> "한 가지 일을 하되 잘 하라" - 유닉스 철학

위 두개의 문장은 오늘 알아 볼 Micro Service Architectur(이하 MSA)를 잘 표현한 문장이다.
이름에서 유추할 수 있듯 MSA는 기능을 작은 어플리케이션 단위로 쪼개어 운영 및 개발을 하는 방법이다. 오늘은 이 MSA가 나온 배경과 간단한 특징에 대하여 공부를 해보자.

---

### MSA의 등장배경
우선 우리는 MSA가 등장하기 전까지 어떠한 방식으로 개발을 진행해 왔는지 살펴 볼 필요가 있다.
기존에는 Monolithic Architecture를 많이 사용하였는데 쉽게 설명하자면 모든 소프트웨어 구성요소를 한 프로젝트에 통합하여 관리, 운영, 개발하는 형태이다.
현재기준으로 내가 개발해왔던 프로젝트들 및 현재 개발되어있는 많은 소프트웨어는 Monolithic 형태로 구현이 되어 있다. 
소규모 프로젝트에서는 Monolithic 아키텍쳐가 간단하며 유지보수가 용이하여 훨씬 합리적이기 때문이다.

하지만 여러 언어를 사용하여 개발된 서비스 혹은 수백명의 개발자가 투입되는 프로젝트의 경우 Monolithic 아키텍쳐는 아래와 같은 문제점들이 발생한다.

* 서비스/프로젝트가 커지면 커질수록, 영향도 파악 및 전체 시스템 구조의 파악에 어려움이 생긴다.
* 빌드 시간 및 테스트시간, 배포시간이 기하급수적으로 늘어나게 된다.
* 서비스를 부분적으로 scale-out 하기가 힘들다.
* 부분의 장애가 전체 서비스의 장애로 이어지는 경우가 발생한다.

위와 같은 문제점을 해결하기 위해 MSA에서는 **비즈니스 민첩성**과 관련이 굉장히 큰 아키텍쳐이다.

---

### MSA 정의
아래 사진은 Monolithic 아키텍쳐와 MS 아키텍쳐를 비교한 사진이다.

![8401](https://user-images.githubusercontent.com/96015600/153874437-3eee8fc5-8aa3-41ad-bfaa-39be5d09cd27.png)

* 각각의 서비스는 크기가 작아질 뿐, **서비스 자체는 Monolithic 아키텍쳐와 유사한 구조**이다.
* 각각의 서비스를 **독립적으로 배포가 가능**해야 한다.
* 각각의 서비스는 **다른 서비스에 대한 의존성이 최소화** 되어야 한다.
* 각 서비스는 <b>개별 프로세스</b>로 구동 되며, **REST와 같은 가벼운 방식**으로 통신되어야 한다.

보통 하나의 서비스는 하나의 기능이며, 비즈니스 및 시스템의 실정에 맞게 서비스의 범위를 설정하는 것이 중요하다.

---

### MSA의 장단점
아래에는 내가 이해한 내용을 바탕으로 예시를 작성하였음.

#### MSA의 장점
* 배포 관점
  * 서비스 별  개별 배포 가능 ( 배포 시 전체 서비스의 중단이 없음 )
    * 예시 ) 로그인 기능에 에러가 발견될 시 로그인과 관련된 마이크로 서비스만 디플로이를 진행하면 됨. 즉, 로그인 이외의 다른 서비스는 로그인 기능이 디플로이 되는 동안 기능이 중지되지 않음. 로그인 기능만디플로이 하기때문에 디플로이 시간이 비교적 짧음
* 확장 관점
  * 특정 서비스에 대한 확장성이 용이함
    * 예시 ) 유저가 상품을 조회하는 부분에서 서버 리소스가 많이 발생하고 있을 때 MSA의 경우 상품 조회 관련 서비스의 서버 스케일을 증설 해주면 됨.
* 장애 관점
  * 장애가 전체 서비스로 확장될 가능성이 적음
    * 로그인 기능에 장애가 발생하더라도 컨텐츠 조회 및 컨텐츠 생성 등 다른 기능들은 다른 서비스로 독립적으로 구현되어 있으므로 영향을 받지 않음.
    
####MSA의 단점
Monolithic 아키텍쳐는 단순한 아키텍쳐인데 비해 MSA는 보다 복잡한 아키텍쳐로, 전체 서비스가 커짐에 따라 그 복잡도가 기하급수적으로 늘어날 수 있다.
이러한 이유로 소규모 스타트업에서는 MSA를 안쓰는 경우가 잦으며 부분적으로 사용하거나 서비스의 크기를 비교적 크게 잡는다.
* 성능 관점
  * 서비스 간 호출 시 API를 사용하기 때문에, 통신 비용이나, Latency가 그만큼 늘어나게 된다.
* 테스트 / 트랜잭션 관점
  * 서비스가 분리되어 있기 때문에 테스트와 트랜잭션의 복잡도가 증가하고, 많은 자원을 필요로 하다.
* 데이터 관리 관점
  * 데이터가 여러 서비스에 걸쳐 분산되기 때문에 한번에 조회하기 어렵고, 데이터의 정합성 또한 관리하기 어렵다.

---
아래는 이 글을 작성하기 위해 참고한 정보들 목록이다.

1.[CLIPSOFT](http://clipsoft.co.kr/wp/blog/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98msa-%EA%B0%9C%EB%85%90/) <br>
2.[에스코어](https://s-core.co.kr/insight/view/%EB%8B%B9%EC%8B%A0%EC%9D%98-msa%EB%8A%94-%EC%95%88%EB%85%95%ED%95%98%EC%8B%A0%EA%B0%80%EC%9A%94-msa%EB%A5%BC-%EB%B3%B4%EC%99%84%ED%95%98%EB%8A%94-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-edmevent-drive/) <br>
3.[Shaul님 기술블로그](https://shaul1991.medium.com/%EC%B4%88%EB%B3%B4%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%BC%EC%A7%80-%EB%8C%80%EC%84%B8-msa-%EB%84%88-%EB%AD%90%EB%8B%88-efba5cfafdeb) <br>
4.[tedigom님 기술블로그](https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e)
