## [파이썬] 비동기 프로그래밍
프로그래밍의 패러다임 변화 중 한가지인 동시프로그래밍에서 비동기프로그래밍으로의 변화에 대해 왜, 어떻게 변하는지 알아보도록 하자.

### 동시 프로그래밍이란?
동시 프로그래밍(concurrent programming)은 여러 개의 쓰레드를 활용하여 이루어져있다. 이를 통해 여러개의 일을 <b>동시에 실행되는 것 같이 보이는 것</b>처럼 동작한다.
하지만 실제는 그렇지 않는데 예시를 들어서 설명을 해보겠다. 아래 그림을 확인해보자.

![동시성과병렬성.png](https://user-images.githubusercontent.com/96015600/163803101-a08e1a92-c47d-4646-aabf-f13ab6a776f4.png)

가장 왼쪽부터 각각 순차적, 동시성, 병렬성을 토대로 처리를 하게 되었을때의 과정이다.
* Sequential(순차) : 하나의 작업을 끝까지 완료 한 후 다음 작업을 진행한다.
* Concurrent(동시) : 두개의 작업을 번갈아가며 진행한다. 이때 다른 작업으로 바꾸어 실행할 때마다 내부적으로는 Context switch가 일어난다.
* Parallel(병렬) : 멀티 코어를 통해 두개의 작업을 한 번에 처리한다.

즉 흔히들 착각하는 동시성과 병렬성은 위 와같은 차이가 존재하는 것이다. 동시성은 논리적으로 <b>많은 것</b>을 처리 한다면 병렬성은 물리적으로 한 번에 많은 <b>일</b>을 처리 하는것을 의미한다.
위에서 나온 <b>Context switch</b>는 다음에 더 자세히 다루어 보겠다.

### 동시 프로그래밍의 패러다임 변화
동시프로그래밍은 위에서 설명하듯 결국 여러개의 쓰레드를 활용하여 작업을 처리한다. 하지만 쓰레드를 이용하여 작업할 경우 thread safe한 프로그램을 작성하는 것은 생각보다 쉬운 일이 아니다.
특히나 싱글코어 프로세서에서 프로그램을 돌릴 경우 동시 처리에 따른 성능 향상이 미미하거나 오히려 저하되는 경우도 발생하게 된다.

이러한 문제들로 인하여 최근에는 하나의 쓰레드를 통해 동시 처리를 하는 비동기 프로그래밍(asynchronous programming)이 주목받고있다.

### 비동기 프로그래밍
웹 서버와 같은 애플리케이션의 경우 CPU 연산 비용보다 DB나 API 연동 등 네트워크과정에서 발생하는 대기 시간이 훨씬 길다.
이러한 문제를 개선하기 위해 비동기 프로그래밍은 대기 시간을 없애고 해당 시간에 CPU가 다른 처리를 할 수 있도록한다.
이러한 작업을 흔히 <b>"non-blocking하다"</b>라고 표현한다.

js와 같이 초기부터 비동기 방식으로 동작하도록 설계된 언어와는 달리 파이썬과 같이 기본적으로 동기 방식으로 동작하는
언어의 경우 이 개념이 생소하게 느껴질 수 있다. 하지만 파이썬 3.4에서 부터 ```asyncio```가 표준 라이브러리로 추가된 후 
3.5부터 ```async/await```키워드가 문법으로 채택되어 파이썬도 자체적으로 비동기 프로그래밍이 가능해졌다.

### 파이썬으로 비동기 프로그래밍 해보기
파이썬에서 ```def```를 통해 선언된 모든 함수는 기본적으로 동기 방식으로 동작한다.
예를 든다면 아래의 함수는 동기함수이다.
```python
def do_sync():
    pass
```

기존 ```def```키워드 앞에 ```async```키워드까지 붙이면 이 함수는 비동기 처리가 된다. 
이러한 비동기 함수를 파이썬에서 코루틴(coroutine)이라고도 부른다. 코루틴 함수가 어떤 원리로 동작하고 어떻게 처리되는 지 등 더 자세한
내용은 다음에 다루도록 하겠다.

```python
async def do_async():
    pass
```
위와같은 비동기 함수는 일반 동기 함수와 달리 기존대로 호출시 coroutine 객체가 반환된다.
```python
do_async() # 반환 결과 : <coroutine object do_async at 0x1038de710>
```

그렇기 때문에 비동기 함수는 일반적으로 ```async```로 선언된 다른 비동기 함수 내에서 ```await```키워드를 붙여서 호출해야한다.
이 과정은 JS에서 async로 선언된 비동기 함수를 호출할 때 await 키워드를 붙이지 않을시 <b>Promise 객체를 리턴</b>하는 것과 같은 원리이다.

만약 꼭 ```async```로 선언되지 않은 일반 동기 함수에서 비동기 함수를 호출해야한다면 ```asyncio 라이브러리의 <b>이벤트 루프</b>를 이용해야 한다.

```python
import asyncio

async def main_async():
    pass

# python 3.5 이상 3.7 미만 버전
loop = asyncio.get_event_loop()
loop.run_until_complete(main_async())
loop.close()

# python 3.7 이상 버전
asyncio.run(main_async())
```
---
### 실제 코드로 비교해보기
이제 사용자 관리 애플리케이션을 흉내내는 실습 코드를 작성하여 동기와 비동기 처리를 비교해보겠습니다.
이 글의 대부분은 <b>DaleSeo</b>님의 글을 참조하였으며 지금 진행 할 실습 프로젝트 설정역시 <b>DaleSeo</b>님의 설정을 그대로 참고하여 진행하겠습니다.

<b>테스트 환경</b>
* 애플리케이션을 사용자 데이터를 직접 보관하지 않고 외부 API를 호출해서 가져옵니다.
* 외부 API는 1명의 사용자 데이터를 조회하는데 1초가 걸리고, 한 번에 여러 사용자의 데이터를 조회할 수 없습니다.
* 각각 3명, 2명, 1명의 사용자 정보를 조회하는 요청 3개가 동시에 애플리케이션에 들어옵니다.

### 동기 프로그래밍
우선 사용자 데이터 조회를 동기 방식으로 처리해주는 ```find_users_sync``` 함수를 작성한 뒤 성능 비교를 위하여
의도적으로 1초의 지연 시간을 발생시켜 줄 것이다. 이 후 3개의 요청을 동기 처리하는 ```process_sync```함수를 작성한다.
```python
import time

def find_users_sync(n):
    for i in range(1, n + 1):
        print(f'{n}명 중 {i}번 째 사용자 조회 중 ...')
        time.sleep(1) # 의도적인 시간 지연
    print(f'> 총 {n} 명 사용자 동기 조회 완료!')

def process_sync():
    start = time.time()
    find_users_sync(3)
    find_users_sync(2)
    find_users_sync(1)
    end = time.time()
    print(f'>>> 동기 처리 총 소요 시간: {end - start}')

if __name__ == '__main__':
    process_sync()

```

위 코드를 실행시켜보면 ```find_users_sync```함수가 총 6초동안 3번 순차적으로 실행된다.
``` shell
3명 중 1번 째 사용자 조회 중 ...
3명 중 2번 째 사용자 조회 중 ...
3명 중 3번 째 사용자 조회 중 ...
> 총 3 명 사용자 동기 조회 완료!
2명 중 1번 째 사용자 조회 중 ...
2명 중 2번 째 사용자 조회 중 ...
> 총 2 명 사용자 동기 조회 완료!
1명 중 1번 째 사용자 조회 중 ...
> 총 1 명 사용자 동기 조회 완료!
>>> 동기 처리 총 소요 시간: 6.020448923110962
```
위와 같은 방식으로 웹 서버가 동작하게 된다면 실제 사용자는 얼마나 오랫동안 지연을 경험하게 될 지 예측해보자.
~~끔찍하다~~ 동기 처리는 선행되는 작업이 끝나야 이후 작업에 들어간다. 위와 같은 경우 첫 번째 함수의 3명 사용자 조회가 완료되어야
두번째 함수가 실행, 완료 후 세번째 함수가 실행 완료되는 과정을 거치는 것이다. 즉, 한 사람을 조회하는데 1초의 시간이 소요된다고 가정할 때 
첫번째 요청은 3초 2번째 요청은 5초 (3+2), 세 번째 요청은 6초(3 + 2 + 1)가 걸리게 된다. 실제 사용자라면 늦게 요청을 보낸 사람은 앞선 사람들만큼
대기 시간이 길어지기 때문에 트래픽이 조금만 쌓여도 문제가 발생될 것이다.

---
### 비동기 프로그래밍
위에서 작성된 동기 함수와 다르게 비동기 함수는 ```async/await``` 키워드를 사용하여 한 번 비동기 처리될 수 있도록 개선해보았다.
기존의 함수 선언에 ```async```를 붙여 비동기 함수(coroutine)로 변경하였으며, 

time.sleep 대신 ```async.sleep``` 함수를 사용하여 1초의 지연을 발생시켰다.
time.sleep 함수는 기다리는 동안 CPU를 그냥 놀리는 반면에, ```asyncio.sleep``` 함수는 CPU가 놀지 않고 다른 처리를 할 수 있도록 해준다.
여기서 주의할 점은 ```asyncio.sleep``` 자체도 비동기 함수이기 때문에 호출할 때 반드시 await 키워드를 붙여야 한다는 점을 명심해야한다.

```python
import time
import asyncio

async def find_users_async(n):
    for i in range(1, n + 1):
        print(f'{n}명 중 {i}번 째 사용자 조회 중 ...')
        await asyncio.sleep(1)
    print(f'> 총 {n} 명 사용자 비동기 조회 완료!')
    
async def process_async():
    start = time.time()
    await asyncio.wait([
        find_users_async(3),
        find_users_async(2),
        find_users_async(1),
    ])
    end = time.time()
    print(f'>>> 비동기 처리 총 소요 시간: {end - start}')

if __name__ == '__main__':
    asyncio.run(process_async())
    """ 3.7이하 버전은 asyncio.run(process_async()) 대신 아래 세줄을 실행시켜야 한다.
    loop = asyncio.get_event_loop()
    loop.run_until_complete(process_async())
    loop.close()
    """
    

```
코드 작성이 완료되었으니 위 코드를 실행한 결과를 확인해보자.
```shell
1명 중 1번 째 사용자 조회 중 ...
2명 중 1번 째 사용자 조회 중 ...
3명 중 1번 째 사용자 조회 중 ...
> 총 1 명 사용자 비동기 조회 완료!
2명 중 2번 째 사용자 조회 중 ...
3명 중 2번 째 사용자 조회 중 ...
> 총 2 명 사용자 비동기 조회 완료!
3명 중 3번 째 사용자 조회 중 ...
> 총 3 명 사용자 비동기 조회 완료!
>>> 비동기 처리 총 소요 시간: 3.0034658908843994
```
결과를 보면 알 수 있듯이 비동기 처리된 코드는 호출 순서와 무방하게 실행 시간이 짧을 수록 먼저 처리되는 것을 알 수 있다.
게다가 실질적으로 총 소요 시간이 6초에서 3초로 100% 단축되었다.
실제 사용자 관점에서 생각해보면 3초가 걸리는 요청을 기다리지 않고 1초가 걸리는 요청은 1초만에 2초가 걸리는 요청은 2초만에 응답이 오니
매우 이상적인 것이다.

비동기 처리는 실행순서가 보장되지 않기 때문에, 위 코드를 그대로 했다고해서 결과의 실행 순서가 필자와 완벽하게 일치하지 않을 수 있다.
여기서 중요한 점은 <b>CPU가 놀지 않고 불필요한 지연없이 3개의 요청이 실행되어야 한다는 것이다.</b>

### 정리
오늘은 동시프로그래밍과 비동기프로그래밍에 대해 간략하게 알아보았다. DaleSeo님께서 잘 정리해주신 덕분에 알 수 있었던게 많았고
공부해야할 것들도 많이 생긴 것 같다. 우린 얼마나 효율적으로 코딩을 하고있을까라는 의문을 던지며 비동기 프로그래밍과 같은 기법을 적용하여 코딩 효율성을 높여보자.


---
### 출처
[DaleSeo님 개발 블로그](https://www.daleseo.com/python-asyncio/) <br>
[곰팡님 개발 블로그](https://gompangs.tistory.com/entry/OS-Thread-Safe%EB%9E%80) <br>
[IT 엘도라도님 개발 블로그](https://it-eldorado.tistory.com/159) <br>
[Smart Tiger님 개발 블로그](https://seamless.tistory.com/42)
