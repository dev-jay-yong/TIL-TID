### 코딩테스트 - 사탕나누기

오늘은 제가 훈련소에 있을때 회사 동료분이 인편으로 보내주신 문제를 풀어볼 예정입니다.
손코딩으로 풀었다보니 코드가 조금 더 난잡해 보일 수 있는 점은 참고 부탁드립니다. 또한 아래부터는 편의를 위해
존댓말은 생략하겠습니다.

### 문제
```
나연이는 A개의 사탕을, 다현이는 B개의 사탕을 갖고 있다. 두 사람은 아래와 같은 작업을 정확히 K번 반복하려고 한다.

- 둘 중 사탕의 개수가 더 적은 사람을 X, 더 많은 사람을 Y라고 한다. (단 두, 사람이 같은 개수의 사탕을 가지고 있다면 나연이가 X 다현이가 Y이다.)

- X가 P개의 사탕을, Y가 Q개의 사탕을 갖고 있을 때 Y는 X에게 자신의 사탕 P개를 준다. 결과적으로 X가 가진 사탕은 2P개, Y가 가진 사탕은 Q-P개가 된다. 
  작업이 끝나고 난 후, 두 사람이 각각 가지고 있는 사탕의 개수를 A'(A 프라임), B'(B 프라임)이라고 하자. MIN (A', B')의 값은 얼마일까?
  
==== 입력 ====
첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
각 테스트 케이스는 하나의 줄로 이루어지며, 각 줄에는 세 개의 정수 A, B, K (1 <= A, B<= 1^9, 1<= k <= 2*10^9)가 공백 하나를 사이에 두고 주어진다.

==== 출력 ====
각 테스트 케이스마다, K번의 반복 작업이 끝나고 난 후, 두 사람이 각각 가지고 있는 사탕의 개수를 A', B'라고 할 때 Min(A' B')의 값을 한 줄에 하나씩 출력한다.

=== 자원 제약 ===
시간 : 150개 테스트케이스를 합쳐서 C의 경우 1초 / C++의 경우 1초 / Java의 경우 2초 / Python의 경우 3초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
```

### 첫번째 풀이 방법
진짜 매우 간단하게 문제에서 요구하는 내용을 풀어보았다.
결과적으로는 A개의 사탕과 B개의 사탕 중 작은 것은 2배, 큰 것은 큰 개수 - 작은개수를 시켜주는 작업을 
K번 반복한 후 최종적으로 두 개의 값중 작은 값을 출력하면 되는 문제라고 생각했다.
그렇게 생각하여 탄생한 첫번째 코드는 아래와 같다.

---
```python
test_case_count = int(input())
a = []
b = []
k = []

for test in range(0, test_case_count):
    test_case = input()
    test_case = test_case.split(' ')
    a.append(int(test_case[0]))
    b.append(int(test_case[1]))
    k.append(int(test_case[2]))
    
for i in range(0, test_case_count):
    for j in range(0, k[i]):
        max_count = max(a[i], b[i])
        min_count = min(a[i], b[i])
        a[i] = max_count - min_count
        b[i] = min_count * 2
    print(min(a[i], b[i]))
```

### 문제점
1. 문제의 자원제약을 뒤늦게 보았다... 우선 코드 동작시간이 매우 길거 같아서 안봐도 time limit에 걸릴 거 같았다.
2. 딱봐도 보기싫은 중첩 for 문이 너무 많았다.

### 두번째 풀이 방법
처음에는 속도를 줄이기 위해서 비트 단위 시프트 연산 등 여러가지 방법을 고안해보았으나 결국 방법을 찾지 못하였고
코드적인 부분을 수정하는 것보다 수리적인 방법으로 해결을 할 수 잇을 거 같아 방법을 찾아보았다. 그러던 중 찾았던 규칙은 정답이 <b>일정 배열을 
계속 순차적으로 출력</b>한다는 것이다. 

예를 들자면 4와 9를 입력했을때 기준으로 5 -> 3 -> 6 -> 1 -> 2 -> 4 -> 5 -> 3 ...

<b>이런식으로 [5, 3, 6, 1, 2, 4]가 무한히 반복된다.</b>
이를 이용하여 반복되는 숫자를 스택에 저장하는 식으로 문제를 풀어보려고 코드를 짜는도중 문제를 다시 확인하니 b와 k에 들어가는 값이 각각 최대 10억인 것을 확인했다.
즉 a와 b를 입력 받았을때 k번째의 값을 한 번에 뽑아내지 않는다면 time limit이 걸릴 수 밖에 없는 구조인것이다. 그렇다면 a와 b, k를 통해 값을 받아오는 <b>일반항 공식이
있을 것이라고 결론짓게되었다.</b> 그렇게 생활관에서 금같은 ~~(사실은 할게 없어서 시간이 안가는)~~ 주말하루를 다 보내고 불침번까지 투자한 결과 공식을 찾게되었다. (내가 수학적 지식이 부족해서 찾는데 오래걸린 것 같다..)
찾은 공식은 다음과 같다.

```k번째 A값은 (2A * (2 ** (k-1)) / A + B)의 나머지이다.```

A = 4, b = 9 일때, 첫번째 A값을 구해본다면 (2 * 4) * (2 ** 1) / 13 의 나머지
즉 8 * 1 / 13 의 나머지인 8이된다. 마찬가지 방법으로 B의 값도 5임을 알 수 있다.

즉 우리는 for문을 돌리지 않아도 K번째 A값과 B값을 알 수 있다. 이것을 아래와같이 코드로 구현해보았다.

```python
test_count = int(input())

for count in range(1, test_count + 1):
    a, b, k = map(int, input().split())
    result_a = (2 * a) * (2 ** (k - 1)) % (a + b)
    result_b = (a + b) - result_a
    print(f'#{count} {min(result_a, result_b)}')
```

이게 정답인 줄 알았다.. 그런데 지금 정리를 하면서 보니 입력값에 아래와 같은 값을 넣었을때 계산시간이 10.565초가 나오게된다. 

```
1
500 2000 2000000000
```
그냥 ```result_a = (2 * a) * (2 ** (k - 1)) % (a + b)``` 이 부분 자체가 너무 느리다.. 고로 내일은 이 부분을 어떻게든 개선을 시도해보는도록 하겠다.
~~사실 이걸 정리하면서 발견하자마자 개선을 시도했지만 2시간 시도 결과 실패했다..~~